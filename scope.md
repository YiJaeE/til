# 스코프

1. 프로그래밍 언어는 변수를 선언하고 참조, 할당하는 기본적인 기능을 제공하며 이것으로 프로그램의 상태(state)를 관리한다.

```javascript
var num = 0; // 변수를 선언한다. 이 변수는 increase 함수에 의해 변화한다.

function increase() {
  return ++num;
}

console.log(increase()); // 1
console.log(increase()); // 2
```

2. 변수는 코드의 가장 바깥 영역뿐 아니라 코드 블럭이나 함수 내에서도 선언할 수 있다. 이때 코드 블럭이나 함수는 중첩될 수 있다.

```javascript
var var1 = 1; // 전역 변수

if(true) {
  var var2 = 2; // 코드 블럭 내에서 선언된 변수: 그러나 전역 변수이다.
  if(true) {
    var var3 = 3; // 중첩된 코드 블럭 내에서 선언된 변수: 역시 전역 변수이다.
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언된 변수: 지역 변수
  
  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언된 변수: 지역 변수
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```

위 코드에서 var1, var2, var3은 전역 변수이기 때문에 전역에서 콘솔로 호출하면 값이 반환된다. 그러나 var4와 var5는 함수 내에서 선언된 지역 변수이므로 전역에서 참조할 수 없기 때문에 참조 에러가 뜬다. 이것은 자바스크립트가 함수 레벨 스코프 방식으로 동작하기 때문이다.

따라서 변수는 자신이 선언된 위치에 의해 자신의 유효한 범위 즉, 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다. var1, var2, var3은 전역에서 선언되었으므로 전역에서 호출해도 값을 반환하지만 var4, var5는 선언된 함수 내에서 지역 변수로 선언되었기 때문에 전역에서 호출하면 참조 에러를 반환한다.

```javascript
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x);
}

foo(); // local

console.log(x); //global
```

변수 x는 전역에서 한 번, 지역에서 한 번 선언되었다. 따라서 함수 foo의 반환 값은 함수 내에서 선언된 x의 값인 local이다. 전역에서 콘솔로 x의 값을 호출하면 전역 변수 x의 값인 global이 반환된다. 같은 x 값을 호출하더라도 코드가 실행되는 위치에 따라 값이 달라지는 것이다. 따라서 스코프는 자바스크립트 엔진이 참조할 `변수를 검색할 때 사용하는 규칙`이라고 할 수 있다.

위 코드에서도 전역 변수로 선언된 변수 x는 어느 위치에서나 참조할 수 있지만 함수 foo 내부에 선언된 지역 변수 x는 함수 내부에서만 참조할 수 있다.

```javascript
function foo() {
  var x = 1;
  var x = 2;
  console.log(x);
}
foo(); // 2
```

var 변수는 중복선언을 허용한다. 따라서 위의 코드처럼 x를 같은 스코프 내에서 두 번 선언한다면 먼저 선언된 변수값은 무시되고 나중에 선언된 변수값을 반환한다. 같은 스코프 내에서 중복 선언이 가능하다는 것은 의도치 않게 변수값을 변경할 수 있기 때문에 위험하다.

따라서 `let`과 `const`는 같은 스코프 내에서 중복 선언을 허용하지 않는다.

```javascript
function bar() {
  let x = 1;
  let x = 2;
}
bar(); // SyntaxError: Identifier 'x' has already been declared
```

`let`과 `const` 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.



## 스코프의 종류

| 구분         | 설명                  | 스코프      | 변수      |
| ------------ | --------------------- | ----------- | --------- |
| 전역(global) | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역(local)  | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

변수는 자기가 선언된 위치에 의해 유효한 범위인 스코프가 결정된다. 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수이다.



### 전역과 전역 스코프

전역은 코드의 가장 바깥 영역을 말한다. 전역에서 선언된 변수는 전역 스코프를 갖는다. 전역 변수는 스코프 체인의 가장 상단에 존재하기 때문에 어디에서든 참조할 수 있다.

자바스크립트는 블록 레벨 스코프가 아니라 함수 레벨 스코프를 지원하기 때문에 함수가 아닌 제어문 등에서 var 키워드로 선언된 변수는 전역 변수가 된다.



### 지역과 지역 스코프

지역은 함수 몸체 내부를 뜻한다. 함수 레벨 스코프를 지원하는 자바스크립트의 특성상 지역 변수는 함수 내부에서만 선언될 수 있다. 예를 들어 전역에 중첩 함수가 존재해 1번 영역이 전역, 2번 영역이 외부 함수, 3번 영역을 내부 함수라고 가정하자. 이 경우 3번에서는 자기 스코프 내의 변수와 2번 외부 함수, 1번 전역에 선언된 모든 변수를 참조할 수 있다.

그러나 스코프는 상위 지역을 참조할 수는 있으나 하위 지역은 참조하지 못한다. 따라서 2번 외부 함수에서는 1번 전역에 선언된 변수는 참조할 수 있으나 3번 내부 함수에서 선언된 변수는 참조할 수 없다. 같은 이유로 전역에서는 지역 변수를 참조할 수 없다. 만약 참조할 수 없는 하위 지역의 변수를 호출하면 참조 에러가 발생한다.



## 스코프 체인

함수는 전역에서 정의할 수도 있고 함수 내부에서 정의할 수도 있다. 함수 내부에서 함수가 정의된 것을 '함수의 중첩'이라고 하고, 함수 몸체 내부에서 정의한 함수를 '중첩 함수(nested function)', 중첩 함수를 포함하는 함수를 '외부 함수(outer function)'라고 부른다.

함수가 중첩 가능하므로 스코프 역시 중첩 가능하다. 중첩이 가능하다는 것은 계층적 구조를 갖는다는 뜻이다. 따라서 상위 지역, 하위 지역으로 구분할 수 있다. 이렇게 스코프가 계층적으로 연결된 것을 `스코프 체인`이라고 한다.

> 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

이런 이유로 하위 스코프는 상위 스코프에서 선언한 변수에 모두 접근할 수 있으며 상위 스코프는 하위 스코프에서 선언된 변수에는 접근할 수 없게 된다. 변수가 선언된 스코프에서 상위로만 변수를 찾아나가기 때문이다. 하위 검색은 하지 않는다.

```javascript
var x = "global x";
var y = "global y";

function outer() {
  var z = "outer's local z"
  
  console.log(x); // global x
  console.log(y); // global y
  console.log(z); // outer's local z
  
  function inner() {
    var x = "inner's local x";
    
    console.log(x); // inner's local x
    console.log(y); //global y
    console.log(z); // outer's local z
  }
  
  inner();
}

outer();

console.log(x); // global x
console.log(z); // ReferenceError: z is not defined
```

스코프 체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이루어진 상속과 유사하다.

```javascript
function foo() {
  console.log('global function foo');
}

function bar() {
  function foo() {
    console.log('local function foo');
  }
  foo(); // local function foo
}
bar();
```

함수 역시 변수에 할당되기 때문에 스코프를 갖는다. 따라서 스코프를 `식별자를 검색하는 규칙`이라고 표현하는 것이 바람직하다.



## 함수 레벨 스코프

자바스크립트는 블록 레벨 스코프(Block level scope)가 아니라 함수 레벨 스코프(Function level scope)를 따른다(var 키워드로 선언했을 때). 따라서 함수가 아닌 곳에서 선언한 변수는 모두 전역 변수가 된다.

```javascript
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); // 10
```

위 코드에서 변수 x는 전역에서 한 번, if 문 코드 블럭 내에서 한 번 선언되었다. 그러나 if 문은 함수가 아니기 때문에 if 문 내에서 선언된 변수는 전역 스코프를 갖는다. 따라서 변수 x가 중복 선언된 것처럼 동작하기 때문에 x의 값을 호출하면 10이 반환된다.

```javascript
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

위 코드에서 변수 i는 전역에서 한 번, for 문에서 한 번 선언되었다. for 문 역시 함수가 아니므로 변수 i는 전역 변수가 되어 중복 선언된다. 따라서 의도치 않게 변수의 값이 재할당되어 전역에서 호출한 변수 i는 10이 아니라 5를 반환한다.



## 렉시컬 스코프

스코프를 결정하는 방식에는 두 가지가 있다.

1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.
2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.

1번은 동적 스코프(Dynamic scope)로 정의된 위치보다는 호출된 위치에서 스코프를 결정한다. 따라서 호출 위치에 따라 스코프가 동적으로 변화한다.

2번은 렉시컬 스코프(Lexical scope) 또는 정적 스코프(Static scope)라고 부른다. 함수가 정해진 위치에서 고정된 스코프를 갖는 것이다. 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

자바스크립트는 렉시컬 스코프를 따르기 때문에 함수가 어디서 호출됐는지가 중요하지 않고 어디에서 정의되었는지가 상위 스코프를 결정한다. 따라서 모든 함수 객체가 생성될 때 스코프가 정의되며 함수는 그것을 기억한다. 따라서 함수가 호출되면 자신이 기억하는 스코프로부터 상위 스코프를 사용한다.

```javascript
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

함수 foo 내에 변수 x가 선언되었지만 함수 foo는 함수 bar를 호출한다. 함수 bar는 전역에서 선언되었으므로 함수 bar가 호출하는 변수 x의 값은 1이다. 따라서 함수 foo가 호출한 x의 값 역시 1이 된다.



## 암묵적 전역 변수

var 키워드를 사용하지 않고 변수를 선언하면 함수 내부에서 선언했다 하더라도 암묵적 전역 변수(implicit global)가 된다.

자바스크립트는 파일이 구분되어 있지만 하나의 전역 스코프를 사용한다. 파일마다 독립적인 파일 스코프를 갖지 않기 때문이다. 따라서 자바스크립트 파일이 여러 개 있더라도 그것은 결국 하나의 파일인 것처럼 동작한다.

만약 2개의 자바스크립트 파일에 동일한 이름의 변수가 있다고 하자. 변수 1번은 전역 변수로, 변수 2번은 지역 변수로 선언되었다고 하더라도 파일이 합쳐진 것처럼 동작하는 순간 변수 2번의 값이 의도치않게 변경된다. 혹은 실행 순서에 따라 똑같이 전역 변수로 선언되었다고 가정하면 뒤에 선언된 변수의 값을 덮어쓰게 된다.

이 문제를 방지하기 위해 과거에는 파일을 즉시실행함수처럼 만들어버리기도 했다. 이런 문제를 미연에 방지하기 위해 함수의 스코프를 최대한 좁게 설정하는 것이 바람직하다.
