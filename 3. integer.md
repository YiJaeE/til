<h1>정수</h1>
<p>자바스크립트가 아닌 다른 언어는 정수와 실수의 타입이 다르다. C에서는 정수를 Int라고 하고 실수는 float나 double이라고 하는데 반해 자바스크립트는 모든 수를 double로 쓴다.</p>
<p>double은 8byte인데다 ALU(Arithmetic logic unit)가 아니라 FPU(floating point unit)를 사용한다. ALU보다 FPU가 리소스를 많이 잡아먹는다. 그러나 자바스크립트는 기본적으로 웹을 위한 언어이기 때문에 CPU를 많이 쓰지 않을 거라고 가정한다.</p>
<p>왜냐하면 산술계산(CPU-bound)은 CPU를 많이 잡아먹는데 자바스크립트는 산술계산을 많이 하지 않기 때문이다. 즉, 자바스크립트는 입력과 출력을 반복(I/O-bound)하는 네트워크 언어이다. 자바스크립트는 I/O-bound를 헤비하게 작업할 수 있도록 만들어진 언어이기 때문에 정수와 실수를 나누지 않고 모든 숫자를 double로 처리하기로 한다.</p>
<p>&nbsp;</p>
<h2>정수(integer) 표현</h2>
<ol>
<li>일반적으로 1바이트, 2바이트, 4바이트, 8바이트에 저장한다.</li>
<li>정수는 부호있는 정수(signed)와 정수(unsigned)로 나뉜다.</li>
<li>부호있는 정수의 경우 첫 bit가 양수 혹은 음수의 부호를 나타낸다. (0: 양수 1: 음수)</li>

</ol>
<p>&nbsp;</p>
<p>모든 언어에는 1바이트 자료형이 존재한다. 1byte는 8bit이다. 1바이트를</p>
<p>signed로 표현하면 -2<sup>7</sup> 부터 2<sup>7</sup>-1 이기 때문에 -128부터 127 이다.</p>
<p>unsigned로 표현하면 2<sup>8</sup>-1 이기 때문에 0부터 255 이다.</p>
<p>&nbsp;</p>
<p>1비트로 표현할 수 있는 숫자는 2<sup>1</sup>이기 때문에 0과 1 (0부터 2<sup>1</sup>-1)이다.</p>
<p>&nbsp;</p>
<h3>Integer Overflow</h3>
<p>정수 오버플로우는 정수값이 허용된 가장 큰 값보다 더 커질 때 실제로 저장되는 값이 개발자의 의도와는 달리 아주 작은 수 혹은 음수가 되는 보안 취약점이다. </p>
<p>&nbsp;</p>
<h2>양의 정수 표현</h2>
<p>1byte는 8bit이며 부호비트는 0이다.</p>
<p>&nbsp;</p>
<h2>음의 정수 표현</h2>
<p>부호비트는 1이다. 음수는 2의 보수(two&#39;s complement)로 저장된다.</p>
<p>&nbsp;</p>
<h3>보수</h3>
<h4>9와 10의 보수</h4>
<p>10진수의 보수는 9의 보수(더해도 자릿수가 변경되지 않는 최대 수)와 10의 보수(더하면 자릿수가 변경되는 수)가 있다.</p>
<ul>
<li><p>6은 3의 9의 보수</p>
</li>
<li><p>74는 25의 9의 보수</p>
</li>
<li><p>742는 257의 9의 보수</p>
<p>따라서</p>
</li>
<li><p>743은 257의 10의 보수</p>
</li>

</ul>
<p>&nbsp;</p>
<h4>2의 보수</h4>
<p>0101은 1010의 1의 보수(더했을 때 자릿수가 변경되지 않는 최대 수인 1111이 나오는 수)이다.</p>
<p>2진수의 특성상 2의 보수는 비트를 반전한 1의 보수에 1을 더하면 된다.</p>
<ul>
<li><p>1100의 2의 보수는</p>
<p>1100의 비트를 반전 &gt; 0011 &gt; 더하기 1 = 0100</p>
</li>
<li><p> -43의 2의 보수는</p>
<p>43 = 32+8+2+1 = 0010 1011 &gt; 반전 &gt; 1101 0100 +1 = 1101 0101</p>
<p>이것을 16진수로 변경하면 d5 이다.</p>
</li>

</ul>
<p>&nbsp;</p>
<h2>4bit 연산</h2>
<p>ALU는 가산기(adder)밖에 없다. 따라서 사칙연산을 더하기로 계산해야 한다.</p>
<p>&nbsp;</p>
<h3>뺄셈</h3>
<p>43-25를 계산하려면 43 + (-25)로 계산한다.</p>
<p>43 = 32 + 8 + 2 + 1 = 0010 1011</p>
<p>25 = 16 + 8 + 1 = 0001 1001</p>
<p>25의 음수 구하기 = 1110 0110 + 1 = 1110 0111</p>
<p>43 - 25 = 0010 1011 + 1110 0111 = 1 0001 0010</p>
<p>carry 되는 맨 앞자리 수는 버리므로 연산 결과는</p>
<p>0001 0010 = 2<sup>4</sup> + 2<sup>2</sup> = 18</p>
<p>&nbsp;</p>
<h3>곱셈과 나눗셈</h3>
<p>4bit 곱셈과 나눗셈을 하기 위해서는 8bit가 필요하다.</p>
<p>또한 곱셈과 나눗셈에서 shift라는 과정이 필요한데, 4bit의 곱셈/나눗셈을 하기 위해서는 총 4 번의 shift가 필요하다.</p>
<p>곱셈은 오른쪽으로 shift, 나눗셈은 왼쪽으로 shift를 한다.</p>
<p>곱셈에서 오른쪽으로 shift 하고 난 빈 자리에는 0을 쓰지만, 나눗셈에서 왼쪽으로 shift 하고 난 빈 자리에는 나누고자 하는 수를 2의 보수인 음수로 변환한 수를 더해서 앞자리수가 음수인 1이라면 비교만 한 후 버리고, 양수인 0이라면 앞자리수에 해당 값을 삽입한다.</p>
