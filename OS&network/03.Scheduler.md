# 스케쥴러

어떤 순서대로 프로세스를 실행시킬지 결정하는 것을 스케쥴러라고 한다. 스케쥴러는 스케쥴링 알고리즘에 따라 프로세스를 실행한다.



1. FIFO 스케쥴러

   가장 간단한 스케쥴링 알고리즘이다. FCFS(First Come First Served)로 움직이는 스케쥴러이다. FIFO 스케쥴러는 First In First Out 방식으로 동작하는 QUEUE 방식으로 실행된다.

2. 최단 작업 우선(SJF) 스케쥴러

   Shortest Job First 방식의 스케쥴러이다. 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행시키는 스케쥴링 알고리즘이다.

3. 우선순위 기반(Priority-Based) 스케쥴러

   1. 정적 우선순위: 프로세스마다 우선순위를 미리 지정하는 방식
   2. 동적 우선순위: 스케쥴러가 상황에 따라 우선순위를 동적으로 변경하는 방식

4. Round Robin 스케쥴러: 시분할 시스템 기반

   

**선점형 vs 비선점형 스케쥴러**

스케쥴러는 운영체제가 스스로 CPU를 멈추고 실행시킬 수 있는지 방식에 따라 선점형 스케쥴러와 비선점형 스케쥴러로 나뉜다.

선점형(Preemptive Scheduling): 하나의 프로세스가 실행 중인 프로세스를 멈추고 프로세서(CPU)를 차지할 수 있는 방법

비선점형 스케쥴러(Non-preemptive Scheduling): 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없는 방법



**인터럽트**: CPU가 프로그램을 실행하고 있을 때 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요한 경우에 CPU에 알려서 처리하는 기술



인터럽트는 왜 필요할까?

현재 시점의 OS는 거의 선점형 스케쥴러로 구현되어 있다. 선점형 스케쥴링 알고리즘을 구현하기 위해서는 진행 중인 프로세스를 중단하고 다른 프로세스로 교체하는 처리가 필요하다. 이러한 처리를 해주는 것이 인터럽트 핸들러이다.

프로세스를 교체하는 문제 뿐 아니라 예외상황 즉 CPU가 프로그램을 실행하고 있을 때 입출력 하드웨어 등의 장치나 예외상황이 발생할 경우 CPU가 해당 문제를 처리할 수 있도록 인터럽트가 필요하다.



## 시스템 콜 인터럽트

시스템 콜을 실행시키기 위해서는 강제로 코드에 인터럽트  명령을 넣어서 CPU가 실행해야 한다. 시스템 콜은 사용자 모드에서 커널 모드로 변경해주는 일을 하는데, 그때 인터럽트를 사용해서 모드를 변경하는 등의 처리를 한다.

```
시스템 콜 실제 코드
eax 레지스터에 시스템 콜 번호를 넣고, ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고, 소프트웨어 인터럽트 명령을 호출한다.
인자 예시는 아래와 같다.

mav edx, 1,
mov ebx, 0, 
int 0X80
```



## 인터럽트와 프로세스

프로세스는 일반적으로

* Text(CODE): 코드
* Data: 변수/초기화된 데이터
* Stack: 임시 데이터(함수 호출, 로컬 변수 등)
* Heap: 코드에서 동적으로 만들어지는 데이터

로 이루어져 있고 가장 아래부터 text, data, heap, stack으로 쌓인다. 가비지 컬렉터는 heap에서 동작한다.



## 프로세스간 커뮤니케이션 (InterProcess Communication)

프로세스는 다른 프로세스의 공간에 접근할 수 없다. 그러나 성능을 높이기 위해 여러 프로세스를 만들어서 동시에 실행해 프로세스간 상태 확인 및 데이터 송수신이 필요해진다. 프로세스간에 커뮤니케이션을 해야하는 경우에 IPC라는 통신 방법을 이용한다. 공유하는 file을 만드는 방법이다.

그러나 file을 사용하면 file에 내용을 저장할 수 있을 뿐 다른 프로세스에 직접 접근해서 실시간으로 원하는 데이터 전달이 어렵다는 단점이 있기 때문에 보다 다양한 IPC 기법이 있다. file을 사용하는 방법을 제외하면 모두 커널 공간을 사용한다. 왜냐하면 커널 공간을 공유하기 때문이다.

