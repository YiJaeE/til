# 프로세스

1. 프로세스란?

   프로그램은 ssd(저장매체)에 저장되어 있다. 프로그램을 실행시키면 메모리에 프로그램을 올린 후 실행하게 된다. 이 메모리에 올려진 상태를 프로세스라고 한다. ssd에 저장되어 있는 상태는 바이너리(코드 이미지)라고 한다.

   그럼 응용프로그램은 프로세스냐? 꼭 그렇지는 않을 수 있다. 왜냐하면 하나의 응용 프로그램은 여러 프로세스로 구성되어 있을 수 있기 때문이다. 하나의 응용프로그램을 실행하기 위해서 작은 단위로 쪼개진 동작들 그러니까 `ls | grep file.txt` 라는 두 개의 프로세스가 하나의 동작(전체 목록에서 file.txt라는 파일을 열기)을 할 수 있게 된다. 이러한 구조는 유닉스가 가지고 있는 철학에 기반을 두고 있다.

2. 프로세스 스케줄링

   운영체제의 가장 핵심적인 기능이다.

   1. 배치 처리 시스템

      요청한 작업을 순차적으로 실행하게 되면 한 가지 작업이 끝나기 전에 다른 작업을 할 수가 없어 계속 대기했어야 했다. 시간이 많이 걸리는 작업을 걸어놓고  이후에 자동으로 실행되도록 하는 방식이다.

      ![스크린샷 2020-05-12 오후 5.15.48](../til/OS&network/image/스크린샷 2020-05-12 오후 5.15.48.png)

      위와 같은 프로세스가 있을 경우 배치 처리 시스템은 아래과 같이 동작한다.

      ![스크린샷 2020-05-12 오후 5.16.55](../til/OS&network/image/스크린샷 2020-05-12 오후 5.16.55.png)

   2. 시분할 시스템

      컴퓨터의 응답 시간을 최소화하는 시스템. 다중 사용자가 컴퓨터에 접속할 수 있도록 하기 위해 고안되었다. 응용 프로그램이 CPU를 경유하는 시간을 잘게 쪼개어 실행될 수 있도록 하는 시스템이며 다른 프로그램을 실행하는 동안 응용프로그램이 실행될 수 있는 시간만큼 프로세스를 번갈아가며 지속하는 방식이다.

      ![스크린샷 2020-05-12 오후 5.20.07](../til/OS&network/image/스크린샷 2020-05-12 오후 5.20.07.png)

      위와 같은 프로세스가 있을 경우 시분할 처리 시스템은 아래과 같이 동작한다.

      ![스크린샷 2020-05-12 오후 5.21.06](../til/OS&network/image/스크린샷 2020-05-12 오후 5.21.06.png)

   3. 멀티 태스킹

      시분할 시스템과 기능적인 측면에선 동일하다. 그러나 멀티 태스킹의 목적은 단일 CPU에서 여러 응용 프로그램이 동시에 실행되는 것처럼 보이게 하는 시스템이다. 다중 사용자의 접속을 지원하는 시분할 시스템과 목적에서 차이가 있다.

   4. 멀티 프로그래밍

      CPU의 활용을 극대화하는 스케줄링 알고리즘

      Wait는 저장매체로부터 파일 읽기를 기다리는 시간으로 가정한다. 때문에 프로세스가 Wait 상태가 되면 바로 다음 프로세스로 넘어가는 방식이다.

      프로세스 생성 (new) -> 실행 가능 (ready) -> 실행 중 (running) -> 대기 (wait or blocked) -> 실행 가능 (ready) -> 실행 중 (running) -> 종료 (exit)

      ![스크린샷 2020-05-12 오후 5.27.03](../til/OS&network/image/스크린샷 2020-05-12 오후 5.27.03.png)

      위와 같은 프로세스가 있을 경우 멀티 프로그래밍은 아래와 같이 동작한다.

      ![스크린샷 2020-05-12 오후 5.26.28](../til/OS&network/image/스크린샷 2020-05-12 오후 5.26.28.png)

