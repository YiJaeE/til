# 변수

어떤 단순한 계산식이 있어 결과값을 연산해냈을 때, 변수가 없다면 해당 값을 재사용할 수 있는 방법은 해당 값이 저장되어 있는 메모리 주소에 접근하는 방법 뿐이다. 하지만 자바스크립트는 메모리에 직접 접근할 수 없다. 기억하고 싶은 데이터를 메모리에 저장하고, 저장된 데이터를 읽어들여 재사용하기 위해 변수를 이용한다.



변수는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다.



자바스크립트는 변수에 값을 직접 포함하는 것이 아니라 파이썬처럼 메모리에 저장된 값을 변수가 가리키는 방식으로 동작한다. `a=10` 이라고 a에 10이라는 값을 할당한 것을 `a=20` 으로 변경하면, a 자체가 변경되는 것이 아니라 a가 가리키는 저장된 메모리의 값이 변경된 것이다. 즉, a는 더이상 10을 가리키지 않고, 20을 가리킨다.



`a=10` 에서 a는 변수에 명시한 고유의 이름인 `변수명`이고, 10은 변수에 저장된 값인 `변수값`이라고 부른다. 변수에 값을 저장하는 것을 `할당`이라고 하고, 변수에 저장된 값을 읽어들이는 것을 `참조`라고 한다.



## 변수선언

변수선언이란 변수명(식별자)를 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 사용하려면 반드시 선언이 필요하다. 즉, '선언'은 자바스크립트 엔진에 식별자를 일방적으로 알리는 것이고 '정의'는 식별자의 정체를 알리는 것으로 변수명과 변수값이 모두 필요하다.

변수명과 변수값을 모두 선언했을 때 이것을 "정의되었다"고 한다.



`var result = 10 + 20;`

위와 같은 변수 선언문이 있다. 이것을 컴퓨터는 `var result`와 `result = 10 + 20`으로 쪼개어 생각한다. 그러나 `10 + 20`이라는 표현식을 그대로 메모리에 저장할 수 없으므로 계산한 값 `30`이 메모리에 할당된다. `30`이라는 값이 도출되는 과정을 "평가"한다고 한다.

1. 컴퓨터는 result라는 변수를 선언하고
2. 10 + 20을 계산하고
3. 계산한 값을 메모리에 할당한다.

이 과정을 통해 컴퓨터는 result의 메모리 주소를 기억하고 result를 참조하면 계산한 값을 출력하게 된다.



변수를 선언하면 값을 할당하지 않아도 메모리 공간에 `undefined` 라는 값이 암묵적으로 할당된다.

변수 선언은 `선언 단계` 와 `초기화 단계` 로 수행된다. 선언 단계는 변수명을 등록해 자바스크립트 엔진에 변수의 존재를 알리는 것이고, 초기화 단계는 등록한 변수에 메모리 공간을 확보하고 암묵적으로 `undefined` 값을 할당하는 것이다.



## 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트 엔진은 소스 코드를 순차적으로 실행하기 전에 소스 코드 전체를 먼저 평가한다. 이때 모든 선언문을 찾아내 식별자를 등록하고 초기화한다. 왜냐하면 식별자를 관리하기 위해서이다. 식별자들은 실행 컨텍스트의 렉시컬 환경 안에 있는 환경 레코드에 존재한다. 따라서 변수 선언문보다 변수를 참조하는 코드가 앞에 있더라도 참조 에러가 발생하지 않고 `undefined` 가 출력된다. 즉, 변수 선언은 소스코드가 런타임 시점이 아니라 파싱 타임에 실행된다.

변수 선언문이 파싱 타임에 실행되는 것을 `변수 호이스팅` 이라고 한다. 이 호이스팅은 변수 뿐 아니라 키워드를 사용한 모든 선언문에 적용된다.



## 값의 할당과 재할당

`var a = 10;`

위의 선언문은 변수 선언과 값의 할당을 하나의 문으로 단축 표현한 것이다. 그러나 a라는 변수가 선언되고 `undefined` 값으로 초기화되는 것은 파싱 타임에, 10이라는 값이 할당되어 실행되는 것은 런타임이다. 하나의 문이지만 실행되는 시간이 다르다.

저장된 값을 변경할 수 있는 것은 변수이고, 변경할 수 없다는 그것은 변수가 아니라 상수이다. 상수는 단 한 번만 할당할 수 있는 변수이다.



## var 키워드

`var`는 ES5까지는 변수를 선언하는 유일한 키워드였다. 그런데 ES6에서 `let`과 `const`를 사용해 선언할 수 있다. `var`가 있음에도 불구하고 왜 `let`과 `const`를 만든 이유는 `var`가 갖는 단점 때문이다.

`var`는 블록 레벨 스코프를 활용할 수 없고 중복 선언을 허용한다는 문제가 있다.

`var a = 10;`

`var a;`

라는 변수 선언문이 있을 때 아래에 있는 `a`는 `undefined`를 반환하지 않고 `10`을 반환한다. 왜냐하면 `var`는 중복 선언을 허용하기 때문에 `10`으로 할당된 `a`의 값을 `undefined`로 변경하지 않는다. 이것이 중복 선언을 지양해야 하는 이유이다. 문법적으로 결과를 예측하기가 어렵기 때문이다.
