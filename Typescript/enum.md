# enum

Enum은 Enumeration의 약자로 열거형이라는 뜻이다. 열거형을 사용하면 명명된 상수 집합을 정의할 수 있다. Typescript에서의 열거형은 숫자와 문자열을 모두 제공한다. 열거형은 `enum` 키워드를 사용해 정의할 수 있다.



## 숫자열거형

```typescript
enum Direction {
  Up = 1,
  Down,
  Left,
  Right
}
```

1로 초기화되는 Up이라는 멤버가 있다. 이후에 나열되는 멤버는 1씩 증가한 값을 가진다. 즉, Down = 2, Left = 3, Right = 4와 같다. 초기화를 하지 않는 경우 숫자는 0부터 시작한다.

숫자열거형은 계산 멤버와 상수 멤버로 혼합될 수 있다. 그러나 이 경우

1. 이니셜라이저가 없는 열거형이 먼저 오거나
2. 숫자 상수로 초기화된 숫자열거형 혹은 기타 상수 열거 멤버 뒤에 와야 한다.

때문에 아래와 같은 형식은 허용되지 않는다.

```typescript
enum E {
  A = getSomeValue(),
  B // Error! Enum member must have initializer
}
```



## 문자열열거형

문자열열거형은 숫자열거형과 유사하지만 런타임에서 차이가 있다. 문자열열거형에서 각 멤버는 문자열 리터럴 또는 다른 문자열 열거형 멤버로 계속 초기화되어야 한다.

```typescript
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT"
}
```

문자열열거형은 숫자열거형과 다르게 자동으로 숫자가 증가하는 동작은 하지 않지만 `serialize(직렬화: 공간적으로 동시에 존재하는 상태로 표현되어 있는 데이터를 이것에 대응하는 직렬인 상태로 존재하도록 변환한다)`을 하기에 유리하다는 장점이 있다. 만약 디버깅 중이고 숫자열거형의 런타입 값을 읽어야 하는 경우 값이 정확히 무엇을 뜻하는지 알기 어렵다. 왜냐하면 값 자체가 유용한 의미를 전달하지 못하고 단순히 숫자만을 보여주기 때문이다. 그러나 문자열열거형은 코드가 실행될 때, 열거형 멤버 자체의 이름과 관계없이, 의미있고, 읽을 수 있는 값을 제공한다.



### 이질적인 열거형

이질적인 열거형은 문자열과 숫자로 구성된 혼합열거형이지만 권장되는 방법은 아니다.

```typescript
enum BooleanLikeHeterogeneousEnum {
  No = 0,
  Yes = "YES"
}
```



### 계산된 상수 멤버

각 열거형 멤버는 상수 또는 계산될 수 있는 그것과 관련된 값을 가지고 있다. 열거형 멤버는 다음과 같은 경우 상수로 간주된다.

* 열거형의 첫번째 멤버로 이니셜라이저가 없으면 값 0이 할당된다

  ```typescript
  enum E { x }
  ```

* 이니셜라이저가 없고 앞의 열거형 멤버는 숫자 상수인 경우 현재 열거멤버의 값은 앞의 열거멤버의 값 + 1이다

  ```typescript
  enum E1 { X, Y, Z }
  
  enum E2 {
    A = 1, B, C
  }
  ```

* 열거 멤버는 상수 열거식으로 이니셜라이징 된다. 상수 열거식은 표현할 수 있는 TypeScript식의 하위 집합이다. 표현식은 다음과 같은 경우 상수열거표현식이라고 한다

  * 리터럴 열거식: 문자열리터럴 또는 숫자리터럴을 나타냄
  * 이전에 정의된 상수열거멤버에 대한 참조 (다른 열거형에서 유래되는 것도 가능)
  * 괄호로 묶은 상수열거식
  * 상수열거식에 적용된 +, -, ~ 단항 연산자 중 하나
  * +, -, *, /, %, <<, >>>, &, |, ^ 등 피연산자로써 열거표현이 일정한 이진 연산자

  상수열거표현식이 `NaN` 또는 `Infinity`로 평가되는 것은 컴파일 타임 에러를 일으킨다.

다른 모든 경우에 열거형멤버는 계산된 것으로 간주된다.

```typescript
enum FileAccess {
    // constant members
    None,
    Read = 1 << 1,
    Write = 1 << 2,
    ReadWrite = Read | Write,
    // computed member
    G = "123".length
}
```

