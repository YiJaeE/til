# 전역 변수의 문제점

변수는 선언에 의해 생성되고 할당을 통해 값을 가졌다가 어떤 시점에서 소멸한다. 변수는 생성되고 소멸하는 생명 주기(Life cycle)가 있다. 변수의 생명 주기는 메모리를 효율적으로 이용하기 위해 중요하다.

변수는 자신이 선언된 위치에서 생성되고 소멸한다. 따라서 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같으며 함수 내부에서 선언된 지역 변수는 함수의 호출과 종료에 따라 생성되고 소멸한다.

```javascript
function foo() {
  var x = 'local';
  console.log(x);
  return x;
}

foo();
console.log(x); // ReferenceError: x is not defined
```

지역 변수 x는 함수가 호출되는 순간 생성된다. 런타임 이전에 변수 선언이 먼저 실행된다는 것은 전역 변수에 한정된 것이다. 지역 변수는 함수가 실행되는 순간 변수 선언이 실행된다.

따라서 `var x = 'local'`이라는 지역 변수는 함수 foo가 실행되는 순간 변수 x가 선언되고 undefined로 초기화된다. 이후 함수 내부의 문들이 순차적으로 실행되다가 변수 할당문을 만나면 변수 x에 해당 값이 할당된다. 이후 함수가 종료되면 변수 x도 소멸한다. 즉, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.

따라서 함수 외부에서 호출한 변수 x는 참조 에러를 반환한다.

```javascript
var x = 'global';

function foo() {
  console.log(x);
  var x = 'local';
  return x;
}
foo();
console.log(x); // global
```

함수 foo 내부의 지역 변수 x는 함수 foo가 실행되는 시점에서 생성된다. 따라서 해당 함수 내부에서 변수 x의 값을 호출하면 `local`이 반환된다(콘솔은 변수 할당문이 실행되기 이전이므로 콘솔에 찍히는 값은 undefined이다). 그러나 전역에서 변수 x를 호출하면 전역 변수 x의 값이 반환된다.

따라서 변수 호이스팅은 스코프 단위로 동작한다. 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프 선두로 끌어올려진 것처럼 동작하고, 전역 전체에서 유효하다. 반면 지역 변수의 호이스팅은 변수 선언이 지역 스코프 선두로 끌어올려진 것처럼 동작해 지역 변수는 해당 스코프 내에서만 유효하다.



## 전역 변수의 생명 주기

함수와 달리 전역 코드는 특별한 호출 없이 실행된다. 즉, 전역 코드는 함수 호출과 같이 전역 코드가 실행되는 특별한 진입점(entry point)이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.

함수는 함수의 마지막 문이나 return 문이 실행되면 종료되지만 전역 코드는 마지막 문까지 실행되어 더이상 실행할 문이 없어도 함수처럼 종료되지 않는다. 왜냐하면 전역 코드가 종료되면 애플리케이션이 종료되는 것과 마찬가지이기 때문이다. 따라서 전역 변수는 브라우저를 종료해 애플리케이션을 종료할 때까지 유효하다.



## 전역 변수의 문제점

1. 암묵적 결합

전역 변수를 사용하는 의도는 코드 어디에서든 전역 변수를 참조하겠다는 뜻이다. 이것은 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용하는 것이다. 변수의 유효 범위가 크다는 것은 언제 어디에서 변수의 값이 변경될지 모른다는 문제를 내포한다. 따라서 코드를 예측하기가 어려워진다.



2. 긴 생명 주기

전역 변수의 생명 주기는 애플리케이션의 종료시까지이다. 이것은 전역 변수가 애플리케이션이 종료될 때까지 메모리를 가지고 있어야 한다는 것이다. 암묵적 결합이 이루어지는 전역 변수의 특성상 이 경우 전역 변수의 값이 변경될 위험성이 높아진다. 더군다나 var 키워드는 변수의 중복 선언을 허용하기 때문에 변수명이 중복되거나 중복되어 재할당이 이루어질 가능성도 높다.



3. 스코프 체인 상에서 종점에 존재

스코프 체인 상에서 종점에 존재한다는 것은 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 뜻이다. 전역 변수의 검색 속도가 가장 느리다.



4. 네임 스페이스 오염

자바스크립트는 분리된 파일도 하나의 전역 스코프를 사용한다. 따라서 다른 파일 내에 동일한 이름으로 명명된 변수나 함수가 같은 스코프에 존재하면 의도치 않게 변수의 값이 변경될 가능성이 높다.



## 전역 변수 사용 억제 방법

변수의 스코프는 좁을 수록 좋다. 전역 변수를 반드시 사용해야 할 상황이 아니라면 지역 변수를 사용해야 한다.



### 즉시 실행 함수

즉시 실행 함수는 정의와 동시에 호출되어 단 한 번만 사용할 수 있다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 전역 변수를 생성하지 않는 방법이므로 라이브러리에서 많이 사용한다.

```javascript
(function () {
  var foo = 10;
  // do anything
}());
console.log(foo); // ReferenceError: foo is not defined
```



### 네임 스페이스 객체

전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다. 네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성할 수 있다.

```javascript
var MYAPP1 = {};
MYAPP.name = 'Lee';
console.log(MYAPP.name); // Lee

var MYAPP2 = {};
MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};
console.log(MYAPP.person.name); // Lee
```



### 모듈 패턴

모듈 패턴은 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만드는 것이다.

모듈 패턴은 전역 변수를 억제하는 것은 물론이고 접근 제한자를 제공하지 않는 자바스크립트를 대신해 캡슐화를 구현한다.

```javascript
var Counter = (function () {
  var num = 0;
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

//private member
console.log(Counter.num);
//public member
console.log(Counter.increase());
console.log(Counter.increase());
console.log(Counter.decrease());
console.log(Counter.decrease());
```



#### ES6 모듈

전역 변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다. 그러나 대부분의 브라우저가 ES6 모듈을 완전히 지원하지 않고 있어 만약 ES6 모듈을 사용하려면 SystemJS, RequireJS 등의 모듈 로더 또는 Webpack 등의 모듈 번들러를 사용해야 한다.
