# 자바스크립트

클라이언트 사이드에서의 자바스크립트는 통상적으로 `자바스크립트`라고 부른다. 자바스크립트는 ECMAScript와 Web API(응용프로그램(앱)과 시스템 사이의 경계를 가리키는 용어)로 이루어져 있다. ECMAScript는 ECMA 인터내셔널이라는 곳에서 만든 표준안이다. ECMAScript뿐 아니라 Web API 역시 표준안이 필요하므로(모든 브라우저에서 일반적으로 동작해야 하므로) W3C가 표준안을 만들었다.

서버사이드에서 돌아가는 자바스크립트는 Node.js 라고 부른다. Node.js는 ECMAScript와 Node.js로 이루어져 있다. Node.js는 서버사이드에서 자바스크립트를 동작하게 하는 환경이다. 언어가 아니다.

따라서 EMCAScript가 자바스크립트의 교집합이고 가장 핵심이다.



코어 자바스크립트인 ECMAScript는 자바스크립트와 Node.js 모두 실행할 수 있다. 그러나 자바스크립트는 브라우저 환경에서, Node.js는 서버 환경에서 동작하므로 각각의 환경에서 동작할 수 있도록 API를 제공하며, 각각의 API는 서로의 환경에 간섭하거나 동작할 수 없다. 만약 Web API가 서버 환경에서 동작하거나 Node.js API가 브라우저 환경에서 동작한다면 쓸모도 없을 뿐 아니라 보안에 취약해진 탓에 여러가지 문제를 일으킬 수 있다. 따라서 자바스크립트와 Node.js는 ECMAScript라는 동일한 코어를 사용하지만 각자의 환경에 따라 다른 API를 이용한다.



## 웹 브라우저의 동작

서버와 클라이언트는 함께 있을 수도 있고 아닐 수도 있다. 그러나 대개 클라이언트는 어느 나라, 어느 지역, 어느 연령의 사용자인지 알 수 없기 때문에 사용자가 사용하는 브라우저의 종류 역시 알 수 없다. 따라서 클라이언트 사이드에서는 이론적으로 모든 사용자를 대응해야 하지만 그것은 불가능하므로 보편적으로 사용하는 브라우저를 중심으로 개발한다.

브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹 페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다. 따라서 서버와 클라이언트는 서로 통신해야 한다. 이를 위해 만든 약속이 통신 규약이다.

HTTP 1.0 버전은 하나의 웹 사이트를 로딩하는데 HTML/css/Java Script/이미지를 요청할 때마다 보내주는 것이다. 한 파일을 여러 번 요청하게 된다. HTTP 2.0 버전은 HTML만 요청해도 포함된 css/Java Script/이미지를 한 번에 보내준다. 요청하지 않아도 서버가 판단해서 파일을 주는 것이다.

서버에서 받은 HTML 파일을 브라우저가 하나의 페이지로 표시하는 과정은 아래와 같다.

1. 사용자가 어떤 웹 주소를 요청하면 서버는 해당 주소의 (대개는) 인덱스 HTML을 제공한다.
2. 렌더링 엔진(브라우저 안에 있는 프로그램으로 HTML과 css를 파싱해 렌더 트리를 만들어 페인팅하는 일을 한다)은 읽어들여 메모리에 저장한 HTML 문서를 Parsing하다가 css를 만나면 파싱을 멈추고 css 파일을 서버에 요청한다.
3. css 파일을 파싱해 CSSOM Tree를 만든 후 HTML 파일로 돌아가 중단한 지점부터 다시 파싱한다.
4. 파싱하던 HTML 파일에서 Script 태그를 만나면 HTML 파서가 동작을 멈추고 자바스크립트 엔진이 동작한다. 스크립트는 렌더링 엔진을 사용하는 HTML/css와 달리 자바스크립트 엔진을 따로 사용한다. 이 엔진을 이용해 파싱하면 AST(Abstract Syntax Tree)를 만든다.
5. 자바스크립트 엔진에서의 동작이 끝나면 다시 렌더링 엔진이 동작하며 HTML 파일로 돌아가 중단한 지점부터 파싱을 시작한다.
6. HTML 파일의 파싱이 끝나면 DOM Tree가 만들어지고, 렌더링 엔진은 DOM Tree와 CSSOM Tree를 merge한다. 이것을 Render Tree라고 한다. 즉, Render Tree는 브라우저가 관리하는 메모리에 있는 DOM Tree와 CSSOM Tree를 merge한 것이다.



*자바스크립트 엔진의 소스 코드 실행 과정*

- *토크나이저: 읽어들이면서 문법상 유효한 토큰(스페이스로 구분한다)을 쪼갠다*
- *파서: 토큰들의 의미를 파악해서 메모리에 업로드한다*
- *바이트코드 생성기: 어셈블리어로 변환한다*
- *인터프리터: 각 줄마다의 머신코드를 만든다*



AST는 DOM과 관련이 있을 수도 있고 없을 수도 있는데, 웹 애플리케이션에서 동작하는 AST는 거의 필연적으로 Render Tree에 접근해 DOM과 CSSOM을 조작하게 된다. 그런데 이때 스크립트 태그가 헤드에 위치해있으면 DOM과 CSSOM에 접근할 수 없는 문제가 발생한다. 왜냐하면 접근해야 하는 태그는 아직 파싱되기 전이기 때문이다. 따라서 스크립트 태그가 실행될 때는 DOM과 CSSOM의 파싱이 모두 끝난 시점인 것이 좋다. 그래서 스크립트 태그를 바디가 끝나기 직전에 넣어주는 것이다.



만약 스크립트 태그를 헤드에 넣고 싶다면 스크립트 로딩 지연으로 인한 병목 현상을 근본적으로 방지하기 위해 HTML5부터는 스크립트 태그에 `<async>`태그와 `<defer>` 태그를 추가했다.

```html
<script async> 로딩은 병렬로 진행하되 실행은 HTML 파싱이 끝난 후에 한다.</script>

<script defer> HTML 파싱을 기다리지 않는다. 이 방식은 DOM과 상관없는 스크립트를 쓴다면 사용 가능하지만 웹 애플리케이션에서 DOM과 상관없는 스크립트를 쓸 일이 거의 없으므로 defer 태그를 쓸 일 역시 거의 없다.</script>
```



## 인터프리터

컴파일러는 소스코드를 만든 다음에 별도로 컴파일이라는 작업을 실행해 실행파일을 만든다. 이 실행파일을 실행해야 소스코드가 만들어지는 것이다. 소스코드에 에러가 있으면 컴파일을 하면서 컴파일 에러를 쏟아낸다.

반면 인터프리터는 컴파일이라는 별도의 작업이 필요하지 않다. 소스 코드를 파서가 해석해 바로 내부에서 바이트 코드를 만들어서 실행한다. 자바스크립트는 인터프리터 언어라서 인터프리터가 내장되어 있다. 인터프리터는 일종의 실행기이다. 한줄한줄 처리하며, 실행파일을 만들지 않는다.

컴파일 속도를 제외한 시간을 계산하면 컴파일러가 인터프리터보다 빠르다. 인터프리터는 실행파일을 만들지 않기 때문에 런타임(실행시점)에 에러가 발생하는 위험성이 있다. 즉, 런칭한 다음에 에러날 확률이 컴파일러보다 비교적 높다. 컴파일러가 에러를 완벽하게 잡을 수 있는 것은 아니지만 컴파일 타임에 대부분의 에러를 잡을 수 있어 비교적 안정적이다.

인터프리터는 기본적으로 느리다는 단점이 있는데 이 문제를 해결한 것이 V8 엔진이다. V8 엔진은 인터프리터임에도 불구하고 빠른데, 순수한 인터프리터가 아니라 내부에서 조금씩 컴파일을 하기 때문이다.

그렇다면 왜 여전히 자바스크립트는 인터프리터일까? 실행 파일을 만들지 않고 컴파일 시간을 갖지 않으며 기본적으로 한 줄씩 실행한다는 특징을 가지면 그것은 인터프리터라고 볼 수 있다.
